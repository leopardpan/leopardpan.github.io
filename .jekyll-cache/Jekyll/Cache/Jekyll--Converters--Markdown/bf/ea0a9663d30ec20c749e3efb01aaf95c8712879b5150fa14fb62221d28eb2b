I"3<h2 id="高效的函数">高效的函数</h2>

<h3 id="函数是-python-的头等对象">函数是 Python 的头等对象</h3>

<p>Python 程序中的所有数据都是由对象或对象之间的关系来表示的。①字符串、列表和模块等都是对象。Python 中的函数也不例外，同样是对象。</p>

<p>由于 yell 函数是 Python 中的一个对象，因此像任何其他对象一样，也可以将其分配给另一
个变量：</p>

<pre><code class="language-python">def yell(text):
    return text.upper()+"!"
bark = yell # 这一行没有调用函数，而是获取 yell 引用的函数对象，再创建一个指向该对象的名称 bark。
# 现在调用 bark 就可以执行相同的底层函数对象
bark('hello') # 'HELLO!'
</code></pre>

<p>此时，删除 yell 的引用，不会影响 bark 的引用：</p>

<pre><code class="language-python">del yell
yell('hello') # NameError: name 'yell' is not defined
bark('hello') # 'HELLO!'
</code></pre>

<p>Python在创建函数时为每个函数附加了一个用于调试的字符串标识符，使用函数的 <strong>name</strong> 属性可以访问该标识符：</p>

<pre><code class="language-python">bark.__name__ # 'yell'
</code></pre>

<p>虽然函数的__name__仍然是 yell，但已经无法用这个名称在代码中访问函数对象。名称标识符仅仅用来辅助调试，指向函数的<strong>变量</strong>和函数本身实际上是彼此独立的。</p>

<h3 id="函数可以传递给其他函数">函数可以传递给其他函数</h3>

<p>由于函数是对象，因此可以将其作为参数传递给其他函数。将函数对象作为参数传递给其他函数的功能非常强大，可以用来将程序中的行为抽象出来并传递出去。</p>

<pre><code class="language-python">def greet(func):
    greeting = func("Hi, I am a Python program")
    print(greeting)
greet(bark) # 'HI, I AM A PYTHON PROGRAM!'
</code></pre>
<p>向 greet 函数传递 bark 函数，greeting = bark(“Hi, I am a Python program”) = “HI, I AM A PYTHON PROGRAM!”，然后打印出来。</p>

<p>能接受其他函数作为参数的函数被称为<strong>高阶函数</strong>。高阶函数是函数式编程风格中必不可少的一部分。</p>

<p>Python 中具有代表性的高阶函数是内置的 map 函数。map 接受一个函数对象和一个可迭代对象，然后在可迭代对象中的每个元素上调用该函数来生成结果。map 返回一个迭代器，可以使用 list 函数将其转换为列表。</p>

<pre><code class="language-python">list(map(bark,['hello','hey','hi'])) # ['HELLO!', 'HEY!', 'HI!']
</code></pre>

<p>map 遍历整个列表并将 bark 函数应用于每个元素，然后将结果放入一个列表中。</p>

<h3 id="函数可以嵌套">函数可以嵌套</h3>

<p>Python 允许在函数中定义函数，这通常被称为嵌套函数或内部函数。</p>

<pre><code class="language-python">def speak(text):
    def whisper(t):
        return t.lower()+"..."
    return whisper(text)
speak('Hello, World') # 'hello, world...'
</code></pre>

<p>每次调用 speak 时，都会定义一个新的内部函数 whisper 并立即调用。’Hello, World’被传递给text参数，然后whisper函数被调用，返回whisper(‘Hello, World’) = ‘hello, world…‘,最后speak函数返回这个值。</p>

<p>内部函数可以访问外部函数的局部变量，但外部函数不能访问内部函数的局部变量。也就是说whisper函数可以访问speak函数的text参数，但speak函数不能访问whisper函数的t参数。</p>

<pre><code class="language-python">whisper('Hello, World') # NameError: name 'whisper' is not defined
</code></pre>

<p>whisper 函数的作用域仅限于 speak 函数，因此在 speak 函数外部无法访问它。</p>

<p>那怎么才能从 speak 外部访问嵌套的 whisper 函数呢？由于函数是对象，因此可以将内部函数返回给父函数的调用者.</p>

<p>例如，下面这个函数定义了两个内部函数。顶层函数根据传递进来的参数向调用者返回对应的内部函数：</p>

<pre><code class="language-python">def get_speak_func(text, volume):
    def whisper():
        return text.lower()+"..."
    def yell():
        return text.upper()+"!"
    if volume &gt; 0.5:
        return yell
    else:
        return whisper
get_speak_func('Hello, World', 0.7) # &lt;function get_speak_func.&lt;locals&gt;.yell at 0x7f9b8c0b0d08&gt;
get_speak_func('Hello, world',0.3) # &lt;function get_speak_func.&lt;locals&gt;.whisper at 0x7f9b8c0b0c80&gt;
</code></pre>

<p>也就是说，get_speak_func 实际上不调用任何内部函数，只是根据 volume 参数选择适当的内部函数，然后返回这个函数对象。</p>

<p>如何调用这个函数对象呢？可以像调用普通函数一样调用它：</p>

<pre><code class="language-python">speak_func = get_speak_func('Hello, World', 0.7)
speak_func('Hello') # 'HELLO!'
</code></pre>

<p>这意味着函数不仅可以通过参数接受行为，还可以返回行为。这里的 speak_func 函数就是一个行为。</p>

<h3 id="函数可捕捉局部状态">函数可捕捉局部状态</h3>

<p>内部函数不仅可以从父函数返回，还可以捕获并携带父函数的某些状态。</p>

<p>下面对前面的 get_speak_func 示例做些小改动来逐步说明这一点。新版在内部就会使用
volume 和 text 参数，因此返回的函数是可以直接调用的：</p>

<pre><code class="language-python">def get_speak_func(text, volume):
    def whisper():
        return text.lower()+"..."
    def yell():
        return text.upper()+"!"
    if volume &gt; 0.5:
        return yell()
    else:
        return whisper()

</code></pre>
<p>仔细看看内部函数 whisper 和 yell，注意其中并没有 text 参数。但不知何故，内部函数仍然可以访问在父函数中定义的 text 参数。它们似乎捕捉并“记住”了这个参数的值。
拥有这种行为的函数被称为<strong>词法闭包（lexical closure）</strong>，简称闭包。闭包在程序流不在闭包范围内的情况下，也能记住封闭作用域（enclosing scope）中的值.</p>

<p>词法闭包的一个重要特性是，它们可以捕捉并携带封闭作用域中的状态。这意味着函数不仅可以返回行为，还可以预先配置这些行为。</p>

<pre><code class="language-python">def make_adder(n): 
    def add(x):
        return x + n
    return add # 返回函数对象
plus_3 = make_adder(3) # plus_3 是一个add函数
plus_3(4) # 7
plus_5 = make_adder(5) # plus_5 是一个add函数,但是n的值不同
plus_5(4) # 9
</code></pre>
<p>在这个例子中，make_adder 作为<strong>工厂函数</strong>来创建和配置各种 adder 函数。注意，这些 adder函数仍然可以访问 make_adder 函数中位于封闭作用域中的参数n。</p>

<h3 id="对象也可以作为函数使用">对象也可以作为函数使用</h3>

<p>虽然 Python 中的所有函数都是对象，但反之不成立。有些对象不是函数，但依然可以调用，因此在许多情况下可以将其当作函数来对待。</p>

<p>如果一个对象是可调用的，意味着可以使用圆括号函数调用语法，甚至可以传入调用参数。
这些都由__call__双下划线方法完成。</p>

<pre><code class="language-python">class Adder:
    def __init__(self, n):
        self.n = n
    def __call__(self, x):
        return self.n + x # self.n 是Adder对象的属性，x是调用时传入的参数
plus_3 = Adder(3) # plus_3 是一个Adder对象,调用__init__方法
# 在幕后，像函数那样“调用”一个对象实例实际上是在尝试执行该对象的__call__方法
plus_3(4) # 7，调用__call__方法，返回self.n + x
</code></pre>

<p>在这个例子中，Adder 类的实例可以像函数一样被调用。这是因为 Adder 类定义了__call__方法，这个方法的实现就是一个函数。当然，并不是所有的对象都可以调用，因此 Python 内置了 callable 函数，用于检查一个对象是否可以调用。</p>

<h3 id="lambda-是单表达式函数">lambda 是单表达式函数</h3>

<p>你可能想知道 lambda 有什么独特之处：如果只是比用 def 声明函数稍微方便一点，那有什么大不了的？</p>

<p>来看下面的例子，同时脑海里要记着函数表达式这个概念：</p>

<pre><code class="language-python">(lamba x,y:x+y)(5,3)# 8,lambda表达式的结果是一个函数对象，意味着可以使用圆括号函数调用语法，圆括号之后的参数是传入函数的参数
</code></pre>

<p>从概念上讲，lambda 表达式 lambda x，y：x + y 与用 def 声明函数相同，但从语法上来说表达式位于 lambda 内部。两者的关键区别在于，lambda 不必先将函数对象与名称绑定，只需在 lambda 中创建一个想要执行的表达式，然后像普通函数那样立即调用进行计算。</p>

<p>lambda 和普通函数定义之间还有另一个语法差异。lambda 函数只能含有一个表达式，这意味着 lambda 函数不能使用语句或注解（annotation），甚至不能使用返回语句。
那么应该如何从 lambda 返回值呢？执行 lambda 函数时会计算其中的表达式，然后自动返回表达式的结果，所以其中总是有一个隐式的返回表达式。因此有些人把 lambda 称为<strong>单表达式函数</strong>。</p>

<h4 id="lambda-的用途">lambda 的用途</h4>

<p>从技术上讲，每当需要提供一个函数对象时，就可以使用 lambda 表达式。而且，因为 lambda 是匿名的，所以不需要先分配一个名字.</p>

<p>比如说，可以用lamba表达式来定义简短的key函数：</p>

<pre><code class="language-python">tuples = [(1,'d'),(2,'b'),(3,'c'),(4,'a')]
sorted(tuples,key = lamba x: x[1]) # [(4,'a'),(2,'b'),(3,'c'),(1,'d')]
</code></pre>

<p>上面的例子按照每个元组中的第 2 个值对元组列表进行排序。在这种情况下，用 lambda 函数能快速修改排序顺序。</p>

<p>下面是另外一个例子，使用lambda函数快速改变排序顺序：</p>

<pre><code class="language-python">sorted(range(-5,6),lamba x: x*x) # [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]
</code></pre>

<p>lamba函数的另外应用场景是作为回调函数传递给其他函数。比如，下面的代码使用 lambda 函数来定义一个回调函数，然后将其传递给内置的 filter 函数：</p>

<pre><code class="language-python">list(filter(lambda x: x % 2, range(10))) # [1, 3, 5, 7, 9]
# filter函数的第一个参数是一个函数对象，第二个参数是一个可迭代对象
</code></pre>
<p>lambda 还有一个有趣之处：与普通的嵌套函数一样，lambda 也可以像词法闭包那样工作。</p>

<pre><code class="language-python">
def make_repeater(n):
    return lambda s: s * n
repeat_5 = make_repeater(5)
repeat_5(3) # 15
repeat_5('hello') # 'hellohellohellohellohello'
repeat_3 = make_repeater(3)
repeat_3('hello') # 'hellohellohello'
repeat_3(3) # 9
</code></pre>

<h4 id="lambda-的局限性">lambda 的局限性</h4>

<p>若工作代码用到了 lambda，虽然看起来很“酷”，但实际上对自己和同事都是一种负担。</p>

<p>将 lambda 和 map()或 filter()结合起来构建复杂的表达式也很难让人理解，此时用列表解析式或生成器表达式通常会清晰不少.</p>

<pre><code class="language-python"># 用lambda和filter构建复杂的表达式
list(filter(lambda x: x % 2==0, range(16))) # [0, 2, 4, 6, 8, 10, 12, 14]
# 用列表解析式
[x for x in range(16) if x % 2 == 0] # [0, 2, 4, 6, 8, 10, 12, 14]
</code></pre>

<h2 id="装饰器">装饰器</h2>

<p>Python 的装饰器可以用来临时扩展和修改可调用对象（函数、方法和类）的行为，同时又不会永久修改可调用对象本身。</p>

<p><strong>装饰器的一大用途是将通用的功能应用到现有的类或函数的行为上</strong>，这些功能包括：</p>

<h2 id="函数式编程">函数式编程</h2>

<p>函数式编程通过在函数中定义表达式和对表达式求值完成计算。它尽量避免由于状态变化和使用可变对象引入复杂性，让程序变得简洁明了。</p>

<p>编程范式并没有统一的划分标准。其中两个范式：函数式编程和命令式编程。</p>

<p>在命令式语言（比如 Python）中，计算的状态是通过不同命名空间中变量的值反映的。变量的值决定计算的当前状态，一条语句通过增加或改变（甚至是删除）变量来改变当前状态。“命令式”语言的每一条语句都是一个通过某种方式改变状态的命令。</p>

<p>有两种方法可以返回一系列值，而不是生成器表达式。</p>

<ul>
  <li>编写显式 for 循环：for x in some_iter: yield x</li>
  <li>使用 yield from 语句：yield from some_iter</li>
</ul>

<h2 id="来源">来源</h2>
<p>《Python函数式编程第2版》
《深入理解Python特性》</p>

:ET